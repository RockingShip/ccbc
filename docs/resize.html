<!DOCTYPE HTML>
<!--
    resize.html

        Interactive demonstration with a 5 segment closed bezier path.
-->
<!--
 *  This file is part of ccbc, Closed Continuous Bézier Curves.
 *  Copyright (C) 2020, xyzzy@rockingship.org
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published
 *  by the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 *  along with this program.  If not, see <https://www.gnu.org/licenses/>.
-->
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
	<link rel="shortcut icon" type="image/svg" href="favicon.svg">
	<title>Manipulating a closed B&eacute;zier path by coordinates</title>
	<script src="MooTools-Core-1.6.0.js" type="text/javascript"></script>
	<script src="MooTools-More-1.6.0.js" type="text/javascript"></script>
	<script src="slider.js" type="text/javascript"></script>
	<script src="resize.js" type="text/javascript"></script>
	<style type="text/css">
		body {
			font-family: Verdana, Geneva, sans-serif;
		}
		h1 {
			text-align: center;
		}
		h3 {
			text-align: center;
		}
		svg {
			background-color: #00000000; /* NOTE: alpha=0 */
			-webkit-touch-callout: none;
			-webkit-user-select: none;
			-moz-user-select: none;
			-ms-user-select: none;
			user-select: none;
		}
		canvas {
			position: absolute;
			z-index: -1;
		}
	</style>
</head>
<body>
<h1>Manipulating a closed B&eacute;zier path by coordinates</h1>
<h3>Eliminating control points</h3>

<p>Interactive demonstration with a multi segment closed bezier path with slider for number of segments.</p>
<p>The short green lines are to illustrate where the control points would normally be located.</p>
<p>Move the red dots on the blue line with your mouse/finger.</p>

<p>Position slider to select compression factor.</p>
<div id="slider" class="slider" style="background: #CCC; height: 16px; width: 500px; position: relative">
  <div class="bonk" style="background: #888; width: 16px; height: 16px; position: absolute; top: 0; left: 0;"></div>
  <div class="knob" style="background: #000; width: 16px; height: 16px;"></div>
</div>

<div id="wrapper">
	<canvas id="animated"></canvas>
	<svg id="svg" width="500px" height="500px">
	</svg>
</div>
<div id="txt"></div>
<div id="txt2"></div>

<script type="text/javascript">

	window.addEvent('domready', function () {

		/*
		 * Create UI
		 */

		// get size of SVG
		let svg = document.id("svg");
		let rect = svg.getBoundingClientRect();
		let width = rect.width;
		let height = rect.height;

		// create canvas
		let canvas = document.id('animated');
		canvas.width = width;
		canvas.height = height;

		// access graphics context
		let context = canvas.getContext("2d");

		/*
		 * Create bezier curve
		 */
		let curve = new Curve();
		calcControlsClosed(curve.AX, curve.BX, curve.CX);
		calcControlsClosed(curve.AY, curve.BY, curve.CY);

		let dots = new Dots(svg, context, curve);
		dots.updateDots(curve.AX, curve.AY);

		// load path points
		document.id('txtA').set('text', JSON.encode(curve.AX));
		document.id('txtB').set('text', JSON.encode(curve.BX));

		/*
		 * activate slider
		 */
		let slider = document.id('slider');
		let knob = slider.getElement('.knob');
		let bonk = slider.getElement('.bonk');
		new MySlider(slider, knob, bonk, {
			range: [3, 32],
			steps: 0,
			initialStep: 10,
			onChange: function(value){
				if (0) {
					let newAX = [];
					let newAY = [];
					curve.fastChordLength(value, newAX, newAY);
					curve.AX = newAX;
					curve.AY = newAY;
					calcControlsClosed(curve.AX, curve.BX, curve.CX);
					calcControlsClosed(curve.AY, curve.BY, curve.CY);
					dots.updateDots(curve.AX, curve.AY);

					let canvas = document.id('animated');
					let ctx = canvas.getContext("2d");

					ctx.beginPath();
					ctx.strokeStyle = '#0ff';
					ctx.fillStyle = '#0ff';
					ctx.lineWidth = 2;
					for (let i = 0; i < newAX.length; i++) {
						ctx.moveTo(newAX[i], newAY[i]);
						ctx.arc(newAX[i], newAY[i], 8, 0, 2 * Math.PI);
					}
					ctx.stroke();

					curve.draw(context, 0, width, height);
				} else {
					let tmpAX = [...curve.AX];
					let tmpAY = [...curve.AY];
					let tmpBX = [...curve.BX];
					let tmpBY = [...curve.BY];
					let tmpCX = [...curve.CX];
					let tmpCY = [...curve.CY];
					calc2(tmpAX, tmpAY, tmpBX, tmpBY, tmpCX, tmpCY);

					curve.AX = tmpAX;
					curve.AY = tmpAY;

					calcControlsClosed(curve.AX, curve.BX, curve.CX);
					calcControlsClosed(curve.AY, curve.BY, curve.CY);
					dots.updateDots(curve.AX, curve.AY);

					let canvas = document.id('animated');
					let ctx = canvas.getContext("2d");

					ctx.beginPath();
					ctx.strokeStyle = "#0ff";
					ctx.fillStyle = "#0ff";
					ctx.lineWidth = 2;
					for (let i = 0; i < curve.AX.length; i++) {
						ctx.moveTo(curve.AX[i], curve.AY[i]);
						ctx.arc(curve.AX[i], curve.AY[i], 8, 0, 2 * Math.PI);
					}
					ctx.stroke();

					curve.draw(context, 0, width, height);

				}
				return;


				while (undo.length < value) {
					let row = redo.shift();
					let i = row.id;

					if (!row.d) {
						let init0 = Init0[i];
						let init1 = row.P;
						let AX = [];
						let AY = [];
						let BX = [];
						let BY = [];
						let CX = [];
						let CY = [];
						for (let j=0; j<init1.length; j++) {
							AX[j] = Math.round(init0[init1[j]][0]);
							AY[j] = Math.round(init0[init1[j]][1]);
						}
						if (__.paths[i].closed) {
							// closed
							calcControlsClosed(AX, BX, CX);
							calcControlsClosed(AY, BY, CY);
						} else {
							// open
							calcControlsOpen(AX, BX, CX);
							calcControlsOpen(AY, BY, CY);
						}

						row.P = init1;
						row.AX = AX;
						row.AY = AY;
						row.d = genPath(AX,AY,BX,BY,CX,CY);
						row.cd = genCompress(AX,AY,BX,BY,CX,CY);
						let err = calcError(AX, AY, BX, BY, CX, CY, row.P, __.paths[i].refX, __.paths[i].refY);
						row.errMax = err.errMax;
						row.errAvg = err.errAvg;
					}

					undo.unshift(__.paths[i].row);
					__.paths[i].row = row;
					__.paths[i].set('d', row.d);

				}
				while (undo.length > value) {
					let row = undo.shift();

					let i = row.id;

					redo.unshift(__.paths[i].row);
					__.paths[i].row = row;
					__.paths[i].set('d', row.d);
				}
				// doStatus();
			},
		});

		// draw initial state
		curve.draw(context, 0, width, height);
	});
</script>

<pre>
// array of points that lie on the Bezier path
let A = <span id="txtA"></span>;
// resulting control points conveniently located here
//  B = <span id="txtB"></span>;

// coefficients for a 5 point closed path
let c0 =  3.0/11.0;
let c1 = -1.0/11.0;
let c2 =  1.0/11.0;
let c3 = -3.0/11.0;
let c4 =  1;

// calculate first control point
let B = [
  { x: A[1].x*c0 + A[2].x*c1 + A[3].x*c2 + A[4].x*c3 + A[0].x*c4 ,
    y: A[1].y*c0 + A[2].y*c1 + A[3].y*c2 + A[4].y*c3 + A[0].y*c4 },
  { x: A[2].x*c0 + A[3].x*c1 + A[4].x*c2 + A[0].x*c3 + A[1].x*c4 ,
    y: A[2].y*c0 + A[3].y*c1 + A[4].y*c2 + A[0].y*c3 + A[1].y*c4 },
  { x: A[3].x*c0 + A[4].x*c1 + A[0].x*c2 + A[1].x*c3 + A[2].x*c4 ,
    y: A[3].y*c0 + A[4].y*c1 + A[0].y*c2 + A[1].y*c3 + A[2].y*c4 },
  { x: A[4].x*c0 + A[0].x*c1 + A[1].x*c2 + A[2].x*c3 + A[3].x*c4 ,
    y: A[4].y*c0 + A[0].y*c1 + A[1].y*c2 + A[2].y*c3 + A[3].y*c4 },
  { x: A[0].x*c0 + A[1].x*c1 + A[2].x*c2 + A[3].x*c3 + A[4].x*c4 ,
    y: A[0].y*c0 + A[1].y*c1 + A[2].y*c2 + A[3].y*c3 + A[4].y*c4 } ];

// optionally mirror to second control point
for (let i = 0; i < 5; i++) {
  C[i] = { x: 2 * A[(i + 1) % 5].x - B[(i + 1) % 5].x,
           y: 2 * A[(i + 1) % 5].y - B[(i + 1) % 5].y };
}
</pre>

</body>
</html>
