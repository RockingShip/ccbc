<!DOCTYPE HTML>
<!--
    resize.html

        Interactive demonstration of switching between curve and contour mode.
-->
<!--
 *  This file is part of ccbc, Closed Continuous Bézier Curves.
 *  Copyright (C) 2012, xyzzy@rockingship.org
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published
 *  by the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 *  along with this program.  If not, see <https://www.gnu.org/licenses/>.
-->
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
	<link rel="shortcut icon" type="image/svg" href="favicon.svg"/>
	<title>Switching between Bezier vector and contour bitmap mode</title>
	<script src="MooTools-Core-1.6.0.js" type="text/javascript"></script>
	<script src="MooTools-More-1.6.0.js" type="text/javascript"></script>
	<script src="resize.js" type="text/javascript"></script>
	<script src="pads.js" type="text/javascript"></script>
	<script src="slider.js" type="text/javascript"></script>
	<style type="text/css">
		body {
			font-family: Verdana, Geneva, sans-serif;
		}
		h1, h2, h3, h4, h5 {
			text-align: center;
		}
		div {
			position: relative;
		}
		svg {
			background-color: #00000000; /* NOTE: alpha=0 */
			-webkit-touch-callout: none;
			-webkit-user-select: none;
			-moz-user-select: none;
			-ms-user-select: none;
			user-select: none;
		}
		canvas {
			position: absolute;
			z-index: -1;
		}
		.knob {
			background: #000;
			width: 16px;
			height: 16px;
		}
		.bonk {
			background: #888;
			width: 16px;
			height: 16px;
			position: absolute;
			top: 0;
			left: 0;
		}
	</style>
</head>
<body>
<h3>Switching between Bezier vector and contour bitmap mode</h3>
<h4>Control the bezier curve through the large red pads.</h4>
<p>With inspiration move the pads.</p>
<p>Press the slider knob and hold down, slide to change number of control points.</p>
<p>The curve will self-adapt to the changes.</p>
<p>Hold as long as you like, release and repeat.</p>
<div id="slider" class="slider" style="background: #CCC; height: 16px; width: 500px; position: relative">
	<div class="bonk"></div>
	<div class="knob"></div>
</div>
<span id="numControls"></span>
<button id="butMode"><b>VISUAL</b>/<strike>precise</strike></button>

<div id="wrapper">
	<canvas id="animated"></canvas>
	<svg id="svg" width="500px" height="500px"></svg>
</div>
<div id="txt"></div>
<div id="txt2"></div>
<div id="txt3"></div>
<div id="txt4"></div>

<pre>
// curve control points
let AX = <span id="curveAX"></span>;
let AY = <span id="curveAY"></span>;
</pre>
<p>"Visual/precise" changes how/where control points are added/removed.</p>
<p>You can also choose to copy/store/save the replay log below:</p>
<textarea id="txtReplayLog" rows="3" cols="10"></textarea>

<script type="text/javascript">

	window.addEvent("domready", function () {

		/*
		 * Create UI
		 */

		// get size of SVG
		let svg = document.id("svg");
		let rect = svg.getBoundingClientRect();
		let width = rect.width;
		let height = rect.height;

		// create canvas
		let canvas = document.id("animated");
		canvas.width = width;
		canvas.height = height;

		// access graphics context
		let ctx = canvas.getContext("2d");

		let followCurve = new Curve();
		setup(followCurve, width, height);

		// display initial path points
		document.id("curveAX").set("text", JSON.encode(followCurve.AX));
		document.id("curveAY").set("text", JSON.encode(followCurve.AY));

		// draw followCurve
		ctx.fillStyle = "#eee"
		ctx.fillRect(0, 0, width, height);
		followCurve.draw(ctx);

		// create user pads
		window.pads = new Pads(svg, function (pt, x, y) {
			// update on-curve control point
			followCurve.AX[pt] = x;
			followCurve.AY[pt] = y;

			// apply change to contour
			followCurve.calcControlsClosed(followCurve.AX, followCurve.BX, followCurve.CX);
			followCurve.calcControlsClosed(followCurve.AY, followCurve.BY, followCurve.CY);
			let controlLength = followCurve.calcControlLength();
			followCurve.captureContour(controlLength * followCurve.ratioContour, followCurve.contourX, followCurve.contourY);

			// initial compare contour/curve
			followCurve.compareInit(followCurve.contourX.length * followCurve.ratioCompare, followCurve.contourX, followCurve.contourY);
			followCurve.totalError = followCurve.compare();
		});
		window.pads.updatePads(followCurve.AX, followCurve.AY);
		window.frameNr = 0;

		/*
		 * activate slider
		 */
		let slider = document.id('slider');
		let knob = slider.getElement('.knob');
		let bonk = slider.getElement('.bonk');
		slider = new MySlider(slider, knob, bonk, {
			range: [3, 100],
			steps: 0,
			initialStep: followCurve.AX.length,
			onChange: function (value) {
				// functionality temporarily moved to draw event handler
			},
		});
		document.id("numControls").set("text", "numControls=" + slider.step);

		/*
		 * activate mode button
		 */
		let visualPrecise = true; // default to visual
		const butMode = document.id("butMode");
		butMode.addEvent("click", function () {
			visualPrecise = !visualPrecise;
			if (visualPrecise) {
				butMode.set("html", "<b>VISUAL</b>/<strike>precise</strike>");
			} else {
				butMode.set("html", "<strike>visual</strike>/<b>PRECISE</b>");
			}
		});

		// frame numbers to bump slider step when recording automatically
		let automated = [];
		if (0) {
			visualPrecise = true; // visual mode
			automated = [14*1, 14*2, 14*3, 14*4, 14*5, 14*6, 14*7, 14*8, 14*9, 14*10, 14*16, 14*17-2, 14*18, 14*19+2, 14*20, 14*21+2, 14*22, 14*23, 14*24, 14*25, 600];
		} else if (0) {
			visualPrecise = false; // precise mode
			automated = [14*1, 14*2, 14*3, 14*4, 14*5, 14*6, 14*7, 14*8, 14*9, 14*10, 14*11, 14*12, 14*13+1, 14*14, 14*15+2, 14*16, 14*17, 14*18, 14*19-1, 14*20+2, 450];
			automated = [14*1, 14*2, 14*3, 14*4, 14*5, 14*6, 14*7, 14*8, 14*9, 14*10, 14*11, 14*12, 14*13, 14*14, 14*15+2, 14*16, 14*17, 14*18+2, 14*19, 14*20+2, 450];
		}
		if (automated.length)
			slider.isDragging = true;

		/*
		 * Replay log
		 */
		let replayLog = {
			width : width,
			height: height,
			visualPrecise: visualPrecise,
			trails: [],
		};

		/*
		 * worker queue
		 */
		let numTicks = 0;
		let myTick = function () {
			let delay = 0;
			const ms = Date.now();

			do {
				if (!slider.isDragging) {
					delay = 500; // only fit contour when dragging
				} else {
					// update on-curve controls for better fit
					let ret = followCurve.tick();

					// update stats
					document.id("txt").set("text", "diff=" + followCurve.totalError + " numCompare=" + followCurve.numCompare);

					if (ret) {
						// call again
						numTicks++;
						delay = 0;
					} else {
						// nothing changed
						delay = 500;
					}
				}
			} while (Date.now() - ms < 10);
			setTimeout(myTick, delay);
		};
		setTimeout(myTick, 0);

		/*
		 * interval timer for animation
		 */
		let lastSliderStep = 0; // last slider position
		setInterval(function () {
			// draw frame
			ctx.fillStyle = "#eee"
			ctx.fillRect(0, 0, width, height);
			if (slider.isDragging) {
				// slide gesture
				if (window.pads.pads.length) {
					// starting gesture

					// remove pads
					window.pads.updatePads([], []);

					// capture current contour
					let controlLength = followCurve.calcControlLength(); // determine control net length
					followCurve.captureContour(controlLength * followCurve.ratioContour, followCurve.contourX, followCurve.contourY);
					// and its curve
					followCurve.contourAX = followCurve.AX.slice();
					followCurve.contourAY = followCurve.AY.slice();
				}

				// last save to replayLog
				if (replayLog.trails.length) {
					// append sync point if it changed
					const ticks = replayLog.trails[replayLog.trails.length - 1].ticks;
					if (ticks.length === 0 || ticks[ticks.length - 1] !== numTicks)
						ticks.push(numTicks);
				}

				// update automatic recording
				if (frameNr >= automated[0]) {
					// remove marker
					automated.shift();
					// bump slider step
					if (automated.length)
						slider.step++;
					else
						slider.isDragging = false;
				}

				if (slider.step !== lastSliderStep) {
					// change number of controls
					if (slider.step > followCurve.AX.length) {
						followCurve.increaseControls(slider.step, visualPrecise);
						document.id("numControls").set("text", "numControls=" + slider.step);
					} else if (slider.step < followCurve.AX.length) {
						followCurve.decreaseControls(slider.step, visualPrecise);
						document.id("numControls").set("text", "numControls=" + slider.step);
					}

					// add new coordinate trail to replayLog
					if (replayLog.trails.length === 0 || replayLog.trails[replayLog.trails.length - 1].ticks.length > 0) {
						// add new starting situation
						replayLog.trails.push({
							AX: followCurve.AX.slice(),
							AY: followCurve.AY.slice(),
							contourAX: followCurve.contourAX.slice(),
							contourAY: followCurve.contourAY.slice(),
							ticks: []
						});
					} else {
						// update last marker
						replayLog.trails[replayLog.trails.length - 1].AX = followCurve.AX.slice();
						replayLog.trails[replayLog.trails.length - 1].AY = followCurve.AY.slice();
					}
					numTicks = 0;

					lastSliderStep = slider.step;
				}

			} else {
				if (!window.pads.pads.length) {
					// end of slide gesture

					// last save to replayLog
					if (replayLog.trails.length) {
						// append sync point if it changed
						const ticks = replayLog.trails[replayLog.trails.length - 1].ticks;
						if (ticks.length === 0 || ticks[ticks.length - 1] !== numTicks)
							ticks.push(numTicks);
					}

					// show pads
					window.pads.updatePads(followCurve.AX, followCurve.AY);
					// update replay log
					document.id("txtReplayLog").set("text", JSON.encode(replayLog));
					// invalidate last position
					lastSliderStep = 0;
				}
			}

			// draw curve depending on in curve/contour mode
			if (slider.isDragging) {
				// contour matching
				followCurve.drawCompare(ctx);
				followCurve.drawContour(ctx, followCurve.contourX, followCurve.contourY, "#f00");
				followCurve.drawCurve(ctx, "#00f");
				followCurve.drawCurvePoints(ctx, 2, "#00f");
			} else {
				// simple curve with pad elements
				followCurve.drawCurve(ctx, "#00f");
				followCurve.drawCurvePoints(ctx, 2, "#00f");
			}

			document.id("curveAX").set("text", JSON.encode(followCurve.AX));
			document.id("curveAY").set("text", JSON.encode(followCurve.AY));

			// next frame
			if (automated.length)
				document.id("txt2").set("text", "frame="+frameNr);

			window.frameNr++;
		}, 1000 / 25);

	});
</script>

</body>
</html>
