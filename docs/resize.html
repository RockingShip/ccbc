<!DOCTYPE HTML>
<!--
    resize.html

        Interactive demonstration of switching between curve and contour mode.
-->
<!--
 *  This file is part of ccbc, Closed Continuous Bézier Curves.
 *  Copyright (C) 2020, xyzzy@rockingship.org
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published
 *  by the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 *  along with this program.  If not, see <https://www.gnu.org/licenses/>.
-->
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
	<link rel="shortcut icon" type="image/svg" href="favicon.svg"/>
	<title>Switching between Bezier vector and contour bitmap mode</title>
	<script src="MooTools-Core-1.6.0.js" type="text/javascript"></script>
	<script src="MooTools-More-1.6.0.js" type="text/javascript"></script>
	<script src="resize.js" type="text/javascript"></script>
	<script src="pads.js" type="text/javascript"></script>
	<script src="slider.js" type="text/javascript"></script>
	<style type="text/css">
		body {
			font-family: Verdana, Geneva, sans-serif;
		}
		h1, h2, h3, h4, h5 {
			text-align: center;
		}
		div {
			position: relative;
		}
		svg {
			background-color: #00000000; /* NOTE: alpha=0 */
			-webkit-touch-callout: none;
			-webkit-user-select: none;
			-moz-user-select: none;
			-ms-user-select: none;
			user-select: none;
		}
		canvas {
			position: absolute;
			z-index: -1;
		}
		.knob {
			background: #000;
			width: 16px;
			height: 16px;
		}
		.bonk {
			background: #888;
			width: 16px;
			height: 16px;
			position: absolute;
			top: 0;
			left: 0;
		}
	</style>
</head>
<body>
<h3>Switching between Bezier vector and contour bitmap mode</h3>
<h4>Control the bezier curve through the large red pads.</h4>
<p>With inspiration move the pads.</p>
<p>Press the slider knob and hold down, slide to change number of control points.</p>
<p>The curve will self-adapt to the changes.</p>
<p>Hold as long as you like, release and repeat.</p>
<div id="slider" class="slider" style="background: #CCC; height: 16px; width: 500px; position: relative">
	<div class="bonk"></div>
	<div class="knob"></div>
</div>
<span id="numControls"></span>
<button id="butMode"><b>VISUAL</b>/<strike>precise</strike></button>

<div id="wrapper">
	<canvas id="animated"></canvas>
	<svg id="svg" width="500px" height="500px"></svg>
</div>
<div id="txt"></div>
<div id="txt2"></div>
<div id="txt3"></div>
<div id="txt4"></div>

<pre>
// curve control points
let AX = <span id="curveAX"></span>;
let AY = <span id="curveAY"></span>;
</pre>
<p>"Visual/precise" changes where control points are added/removed.</p>

<script type="text/javascript">

	window.addEvent("domready", function () {

		/*
		 * Create UI
		 */

		// get size of SVG
		let svg = document.id("svg");
		let rect = svg.getBoundingClientRect();
		let width = rect.width;
		let height = rect.height;

		// create canvas
		let canvas = document.id("animated");
		canvas.width = width;
		canvas.height = height;

		// access graphics context
		let ctx = canvas.getContext("2d");

		let followCurve = new Curve();
		setup(followCurve, width, height);

		// display initial path points
		document.id("curveAX").set("text", JSON.encode(followCurve.AX));
		document.id("curveAY").set("text", JSON.encode(followCurve.AY));

		// draw followCurve
		ctx.fillStyle = "#eee"
		ctx.fillRect(0, 0, width, height);
		followCurve.draw(ctx);

		// create user pads
		window.pads = new Pads(svg, function (pt, x, y) {
			// update on-curve control point
			followCurve.AX[pt] = x;
			followCurve.AY[pt] = y;

			// apply change to contour
			followCurve.calcControlsClosed(followCurve.AX, followCurve.BX, followCurve.CX);
			followCurve.calcControlsClosed(followCurve.AY, followCurve.BY, followCurve.CY);
			let controlLength = followCurve.calcControlLength();
			followCurve.captureContour(controlLength * followCurve.ratioContour, followCurve.contourX, followCurve.contourY);

			// initial compare contour/curve
			followCurve.compareInit(followCurve.contourX.length * followCurve.ratioCompare, followCurve.contourX, followCurve.contourY);
			followCurve.compareBalance();
			followCurve.totalError = followCurve.compare();
		});
		window.pads.updatePads(followCurve.AX, followCurve.AY);
		window.frameNr = 0;

		/*
		 * activate slider
		 */
		let slider = document.id('slider');
		let knob = slider.getElement('.knob');
		let bonk = slider.getElement('.bonk');
		slider = new MySlider(slider, knob, bonk, {
			range: [3, 100],
			steps: 0,
			initialStep: followCurve.AX.length,
			onChange: function (value) {
				// functionality temporarily moved to draw event handler
			},
		});
		document.id("numControls").set("text", "numControls=" + slider.step);

		/*
		 * activate mode button
		 */
		let visualPrecise = true; // default to visual
		const butMode = document.id("butMode");
		butMode.addEvent("click", function () {
			if (visualPrecise) {
				butMode.set("html", "<strike>visual</strike>/<b>PRECISE</b>");
			} else {
				butMode.set("html", "<b>VISUAL</b>/<strike>precise</strike>");
			}
			visualPrecise = !visualPrecise;
		});

		/*
		 * worker queue
		 */
		let numTicks = 0;
		let myTick = function () {
			let delay = 0;
			const ms = Date.now();

			do {
				if (!slider.isDragging) {
					delay = 500; // only fit contour when dragging
				} else {
					// update on-curve controls for better fit
					let ret = followCurve.tick();
					numTicks++;

					// update stats
					document.id("txt").set("text", "diff=" + followCurve.totalError + " numCompare=" + followCurve.numCompare);

					if (ret) {
						// call again
						delay = 0;
					} else {
						// nothing changed
						delay = 500;
					}
				}
			} while (Date.now() - ms < 10);
			setTimeout(myTick, delay);
		};
		setTimeout(myTick, 0);

		/*
		 * interval timer for animation
		 */
		let alts = undefined; // alternative curves when using the slider
		setInterval(function () {
			// draw frame
			ctx.fillStyle = "#eee"
			ctx.fillRect(0, 0, width, height);
			if (slider.isDragging) {
				if (!alts) {
					alts = [];

					// capture current contour
					let controlLength = followCurve.calcControlLength(); // determine control net length
					followCurve.captureContour(controlLength * followCurve.ratioContour, followCurve.contourX, followCurve.contourY);
					// initial compare contour/curve
					followCurve.compareInit(followCurve.contourX.length * followCurve.ratioCompare, followCurve.contourX, followCurve.contourY);
					followCurve.compareBalance();
					followCurve.totalError = followCurve.compare();

					alts[slider.step] = followCurve;

					// slide gesture starting, remove pads
					window.pads.updatePads([], []);
				}
				if (!alts[slider.step]) {
					// remove pads
					let newCurve = new Curve();

					// copy curve/contour
					newCurve.AX = followCurve.AX.slice();
					newCurve.AY = followCurve.AY.slice();
					newCurve.contourX = followCurve.contourX.slice();
					newCurve.contourY = followCurve.contourY.slice();

					// set initial control points
					newCurve.calcControlsClosed(newCurve.AX, newCurve.BX, newCurve.CX);
					newCurve.calcControlsClosed(newCurve.AY, newCurve.BY, newCurve.CY);

					// initial compare contour/curve
					newCurve.compareInit(newCurve.contourX.length * newCurve.ratioCompare, newCurve.contourX, newCurve.contourY);
					newCurve.compareBalance();
					newCurve.totalError = newCurve.compare();

					// change number of controls
					if (slider.step > newCurve.AX.length)
						newCurve.increaseControls(slider.step, visualPrecise);
					else if (slider.step < newCurve.AX.length)
						newCurve.decreaseControls(slider.step, visualPrecise);

					alts[slider.step] = newCurve;
					document.id("txt3").set("text", slider.step);
				}

				// test if slide changed active curve
				if (followCurve !== alts[slider.step]) {
					// focus on 'selected' curve
					followCurve = alts[slider.step];
					document.id("numControls").set("text", "numControls=" + slider.step);
				}

			} else {
				if (alts) {
					// end of slice gesture, show pads
					window.pads.updatePads(followCurve.AX, followCurve.AY);
					alts = undefined;
				}
			}


			if (0) {
				// capture contour user and inject into follow
				let controlLength = userCurve.calcControlLength(); // determine control net length
				userCurve.captureContour(controlLength * followCurve.ratioContour, followCurve.contourX, followCurve.contourY);
				// initial compare contour/curve
				followCurve.compareInit(followCurve.contourX.length * followCurve.ratioCompare, followCurve.contourX, followCurve.contourY);
				followCurve.compareBalance();
				followCurve.totalError = followCurve.compare();

			}

			// draw curve depending on in curve/contour mode
			if (slider.isDragging) {
				// contour matching
				followCurve.drawCompare(ctx);
				followCurve.drawContour(ctx, followCurve.contourX, followCurve.contourY, "#f00");
				followCurve.drawCurve(ctx, "#00f");
				followCurve.drawCurvePoints(ctx, 2, "#00f");
			} else {
				// simple curve with pad elements
				followCurve.drawCurve(ctx, "#00f");
				followCurve.drawCurvePoints(ctx, 2, "#00f");
			}

			document.id("curveAX").set("text", JSON.encode(followCurve.AX));
			document.id("curveAY").set("text", JSON.encode(followCurve.AY));

			// next frame
			window.frameNr++;
		}, 1000 / 25);

	});
</script>

</body>
</html>
