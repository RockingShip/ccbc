<!DOCTYPE HTML>
<!--
    resize.html

        Interactive demonstration of switching between curve and contour mode.
-->
<!--
 *  This file is part of ccbc, Closed Continuous Bézier Curves.
 *  Copyright (C) 2020, xyzzy@rockingship.org
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published
 *  by the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 *  along with this program.  If not, see <https://www.gnu.org/licenses/>.
-->
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
	<link rel="shortcut icon" type="image/svg" href="favicon.svg"/>
	<title>Switching between Bezier vector and contour bitmap mode</title>
	<script src="MooTools-Core-1.6.0.js" type="text/javascript"></script>
	<script src="MooTools-More-1.6.0.js" type="text/javascript"></script>
	<script src="resize.js" type="text/javascript"></script>
	<script src="pads.js" type="text/javascript"></script>
	<script src="slider.js" type="text/javascript"></script>
	<style type="text/css">
		body {
			font-family: Verdana, Geneva, sans-serif;
		}
		h1 {
			text-align: center;
		}
		h3 {
			text-align: center;
		}
		div {
			position: relative;
		}
		svg {
			background-color: #00000000; /* NOTE: alpha=0 */
			-webkit-touch-callout: none;
			-webkit-user-select: none;
			-moz-user-select: none;
			-ms-user-select: none;
			user-select: none;
		}
		canvas {
			position: absolute;
			z-index: -1;
		}
		.knob {
			background: #000;
			width: 16px;
			height: 16px;
		}
		.bonk {
			background: #888;
			width: 16px;
			height: 16px;
			position: absolute;
			top: 0;
			left: 0;
		}
	</style>
</head>
<body>
<h3>Switching between Bezier vector and contour bitmap mode</h3>

<p>You have control over a bezier curve through the large red pads.</p>
<p>With inspiration move the pads.</p>
<p>Press the slider knob and hold down, slide to change number of control points.</p>
<p>The curve will self-adapt to the changes.</p>
<p>Release and repeat.</p>

<p>Position slider to select number of on-curve control points.</p>
<div id="slider" class="slider" style="background: #CCC; height: 16px; width: 500px; position: relative">
	<div class="bonk"></div>
	<div class="knob"></div>
</div>

<div id="wrapper">
	<canvas id="animated"></canvas>
	<svg id="svg" width="500px" height="500px"></svg>
</div>
<div id="txt"></div>
<div id="txt2"></div>
<div id="txt3"></div>
<div id="txt4"></div>

<pre>
// curve control points
let AX = <span id="curveAX"></span>;
let AY = <span id="curveAY"></span>;
</pre>

<script type="text/javascript">

	window.addEvent("domready", function () {

		/*
		 * Create UI
		 */

		// get size of SVG
		let svg = document.id("svg");
		let rect = svg.getBoundingClientRect();
		let width = rect.width;
		let height = rect.height;

		// create canvas
		let canvas = document.id("animated");
		canvas.width = width;
		canvas.height = height;

		// access graphics context
		let ctx = canvas.getContext("2d");

		let followCurve = new Curve();
		setup(followCurve, width, height);

		// display initial path points
		document.id("curveAX").set("text", JSON.encode(followCurve.AX));
		document.id("curveAY").set("text", JSON.encode(followCurve.AY));

		// draw followCurve
		ctx.fillStyle = "#eee"
		ctx.fillRect(0, 0, width, height);
		followCurve.draw(ctx);

		// create user pads
		window.pads = new Pads(svg, function (pt, x, y) {
			// update on-curve control point
			followCurve.AX[pt] = x;
			followCurve.AY[pt] = y;

			// apply change to contour
			followCurve.calcControlsClosed(followCurve.AX, followCurve.BX, followCurve.CX);
			followCurve.calcControlsClosed(followCurve.AY, followCurve.BY, followCurve.CY);
			let controlLength = followCurve.calcControlLength();
			followCurve.captureContour(controlLength * followCurve.ratioContour, followCurve.contourX, followCurve.contourY);

			// initial compare contour/curve
			followCurve.compareInit(followCurve.contourX.length * followCurve.ratioCompare, followCurve.contourX, followCurve.contourY);
			followCurve.compareBalance();
			followCurve.totalError = followCurve.compare();
		});
		window.pads.updatePads(followCurve.AX, followCurve.AY);
		window.frameNr = 0;

		/*
		 * activate slider
		 */
		let slider = document.id('slider');
		let knob = slider.getElement('.knob');
		let bonk = slider.getElement('.bonk');
		slider = new MySlider(slider, knob, bonk, {
			range: [3, 100],
			steps: 0,
			initialStep: 10,
			onChange: function(value){
				return;
				if (0) {
					let newAX = [];
					let newAY = [];
					curve.fastChordLength(value, newAX, newAY);
					curve.AX = newAX;
					curve.AY = newAY;
					calcControlsClosed(curve.AX, curve.BX, curve.CX);
					calcControlsClosed(curve.AY, curve.BY, curve.CY);
					dots.updateDots(curve.AX, curve.AY);

					let canvas = document.id('animated');
					let ctx = canvas.getContext("2d");

					ctx.beginPath();
					ctx.strokeStyle = '#0ff';
					ctx.fillStyle = '#0ff';
					ctx.lineWidth = 2;
					for (let i = 0; i < newAX.length; i++) {
						ctx.moveTo(newAX[i], newAY[i]);
						ctx.arc(newAX[i], newAY[i], 8, 0, 2 * Math.PI);
					}
					ctx.stroke();

					curve.draw(context, 0, width, height);
				} else {
					let tmpAX = [...userCurve.AX];
					let tmpAY = [...userCurve.AY];
					let tmpBX = [...userCurve.BX];
					let tmpBY = [...userCurve.BY];
					let tmpCX = [...userCurve.CX];
					let tmpCY = [...userCurve.CY];
					calc2(tmpAX, tmpAY, tmpBX, tmpBY, tmpCX, tmpCY);

					curve.AX = tmpAX;
					curve.AY = tmpAY;

					calcControlsClosed(curve.AX, curve.BX, curve.CX);
					calcControlsClosed(curve.AY, curve.BY, curve.CY);
					dots.updateDots(curve.AX, curve.AY);

					let canvas = document.id('animated');
					let ctx = canvas.getContext("2d");

					ctx.beginPath();
					ctx.strokeStyle = '#0ff';
					ctx.fillStyle = '#0ff';
					ctx.lineWidth = 2;
					for (let i = 0; i < curve.AX.length; i++) {
						ctx.moveTo(curve.AX[i], curve.AY[i]);
						ctx.arc(curve.AX[i], curve.AY[i], 8, 0, 2 * Math.PI);
					}
					ctx.stroke();

					curve.draw(context, 0, width, height);

				}
				return;


				while (undo.length < value) {
					let row = redo.shift();
					let i = row.id;

					if (!row.d) {
						let init0 = Init0[i];
						let init1 = row.P;
						let AX = [];
						let AY = [];
						let BX = [];
						let BY = [];
						let CX = [];
						let CY = [];
						for (let j=0; j<init1.length; j++) {
							AX[j] = Math.round(init0[init1[j]][0]);
							AY[j] = Math.round(init0[init1[j]][1]);
						}
						if (__.paths[i].closed) {
							// closed
							calcControlsClosed(AX, BX, CX);
							calcControlsClosed(AY, BY, CY);
						} else {
							// open
							calcControlsOpen(AX, BX, CX);
							calcControlsOpen(AY, BY, CY);
						}

						row.P = init1;
						row.AX = AX;
						row.AY = AY;
						row.d = genPath(AX,AY,BX,BY,CX,CY);
						row.cd = genCompress(AX,AY,BX,BY,CX,CY);
						let err = calcError(AX, AY, BX, BY, CX, CY, row.P, __.paths[i].refX, __.paths[i].refY);
						row.errMax = err.errMax;
						row.errAvg = err.errAvg;
					}

					undo.unshift(__.paths[i].row);
					__.paths[i].row = row;
					__.paths[i].set('d', row.d);

				}
				while (undo.length > value) {
					let row = undo.shift();

					let i = row.id;

					redo.unshift(__.paths[i].row);
					__.paths[i].row = row;
					__.paths[i].set('d', row.d);
				}
				// doStatus();
			},
		});

		// alternative curves when using the slider
		let alts = undefined;

		/*
		 * worker queue
		 */
		let myTick = function () {
			let delay = 0;

			if (!slider.isDragging) {
				delay = 500; // only fit contour when dragging
			} else {
				// update on-curve controls for better fit
				let ret = followCurve.tick();

				// update stats
				document.id("txt").set("text", "diff=" + followCurve.totalError + " numCompare=" + followCurve.numCompare);

				if (ret) {
					// call again
					delay = 0;
				} else {
					// nothing changed
					delay = 500;
				}
			}
			setTimeout(myTick, delay);
		};
		setTimeout(myTick, 0);

		/*
		 * interval timer for animation
		 */
		setInterval(function () {
			// draw frame
			ctx.fillStyle = "#eee"
			ctx.fillRect(0, 0, width, height);
			if (slider.isDragging) {
				if (!alts) {
					alts = [];

					// capture current contour
					let controlLength = followCurve.calcControlLength(); // determine control net length
					followCurve.captureContour(controlLength * followCurve.ratioContour, followCurve.contourX, followCurve.contourY);
					// initial compare contour/curve
					followCurve.compareInit(followCurve.contourX.length * followCurve.ratioCompare, followCurve.contourX, followCurve.contourY);
					followCurve.compareBalance();
					followCurve.totalError = followCurve.compare();

					alts[slider.step] = followCurve;
				}
				if (!alts[slider.step]) {
					// remove pads
					window.pads.updatePads([], []);

					let newCurve = new Curve();

					newCurve.AX = followCurve.AX.slice();
					newCurve.AY = followCurve.AY.slice();
					if (slider.step < newCurve.AX.length) {
						newCurve.AX.length = slider.step;
						newCurve.AY.length = slider.step;
					} else {
						while (newCurve.AX.length < slider.step) {
							newCurve.AX.push(newCurve.AX.length*10);
							newCurve.AY.push(newCurve.AY.length*10);
						}
					}
					newCurve.contourX = followCurve.contourX.slice();
					newCurve.contourY = followCurve.contourY.slice();

					// set initial control points
					newCurve.calcControlsClosed(newCurve.AX, newCurve.BX, newCurve.CX);
					newCurve.calcControlsClosed(newCurve.AY, newCurve.BY, newCurve.CY);

					// initial compare contour/curve
					newCurve.compareInit(newCurve.contourX.length * newCurve.ratioCompare, newCurve.contourX, newCurve.contourY);
					newCurve.compareBalance();
					newCurve.totalError = newCurve.compare();

					alts[slider.step] = newCurve;
					document.id("txt3").set("text", slider.step);
				}
				// focus on 'selected' curve
				followCurve = alts[slider.step];
			} else {
				if (alts) {
					// assign new pads
					window.pads.updatePads(followCurve.AX, followCurve.AY);
					alts = undefined;
				}
			}


			if (0) {
				// capture contour user and inject into follow
				let controlLength = userCurve.calcControlLength(); // determine control net length
				userCurve.captureContour(controlLength * followCurve.ratioContour, followCurve.contourX, followCurve.contourY);
				// initial compare contour/curve
				followCurve.compareInit(followCurve.contourX.length * followCurve.ratioCompare, followCurve.contourX, followCurve.contourY);
				followCurve.compareBalance();
				followCurve.totalError = followCurve.compare();

			}

			if (slider.isDragging) {
				followCurve.drawCompare(ctx);
				followCurve.drawContour(ctx, followCurve.contourX, followCurve.contourY, "#f00");
				followCurve.drawCurve(ctx, "#00f");
				followCurve.drawCurvePoints(ctx, 2, "#00f");
			} else {
				followCurve.drawCurve(ctx, "#00f");
				followCurve.drawCurvePoints(ctx, 2, "#00f");
			}

			document.id("curveAX").set("text", JSON.encode(followCurve.AX));
			document.id("curveAY").set("text", JSON.encode(followCurve.AY));

			// next frame
			window.frameNr++;
		}, 1000 / 25);

	});
</script>

</body>
</html>
